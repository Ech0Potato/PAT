# 链表处理

PAT只考静态链表，且模板固定，通用解题步骤如下：

**① 定义静态链表**

```c++
struct Node {

	int address; //结点地址

	typename data; //数据域（目前考过的题都是int型，只有一道是char型）

	int next; //指针域

	XXX; //结点的某个性质，不同的题目会有不同的设置

	（目前只出现过在链表上的序号或者是否为链表上的一个结点）

}node[100010];
```

**② 在程序的开始，对静态链表进行初始化**

一般来说，需要对定义中的XXX进行初始化，将其定义为正常情况下达不到的数字（一般需要小于所有能达到的数字，有时候需要大于所有能达到的数字），例如对结点是否在链表上这个性质来说，可以初始化为0

```c++
for(int i = 0; i < maxn; i++){

	node[i].XXX=0;

}
```

**（其实这中间还有一步读取数据）**

**③ 遍历链表，标记特殊性质，统计有效结点个数**

题目一般都会给出一条链表的首结点的地址，可以依据这个地址来遍历得到整条链表，这一步同时对结点的性质XXX进行标记，并且对有效结点的个数进行计数

```c++
int p = begin, count = 0;

while(p != -1) { //-1代表链表结束

	XXX = 1;

	count++;

	p = node[p]->next;

}
```

**④ 对数组排序以把有效结点移到数组左端**

写sort的排序函数cmp时，可以在cmp的两个参数结点中有无效结点时按XXX从大到小排序（所以步骤②要定义成小于所有能达到的数字，从小到大排序的话就定义成大于所有能达到的数字如maxn），这样就可以把有效结点全部移到数组左端。一般题目中一定会有额外的要求，因此cmp函数中一般需要有第二级排序

```c++
bool cmp(Node a, Node b){

	if(a.XXX==-1 || b.XXX==-1){

		//至少一个结点是无效结点，就把它放到数组后面

		return a.XXX > b.XXX;

	} else {

		//第二级排序

	}

}
```

**⑤ 看题目在排序之后的具体要求（比较常见的是按各种不同的要求输出链表）**

注意：输出的话要根据地址位数输出，如%05d，同时若要输出末尾空结点地址-1需要提前判断，单独输出；这种题要灵活，思考自己的思路，不能一昧套模板，尤其第⑤步要自己想清思路，有时步骤③也能有操作。总之基本模板写下来，主体思路自己想。