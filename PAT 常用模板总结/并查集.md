# 并查集

（1）并查集是一种维护集合的数据结构，即支持合并和查找的集合，用于处理**不相交**集合

   用一个数组表示，即int father[n]，father[i]=j表示i的父亲结点为j

（2）重要性质：对同一个结合来说只存在一个根结点，且将其作为所属集合的标识

​             并查集产生的每一个集合都是一棵树

（3）模板代码如下：

//查找（根结点）

int findRoot(int a) {

​    int b = a;

​    while(a != father[a]) {

​        a = father[a];

​    }

​    //路径压缩

​    while(b != father[b]) {

​        int c = b;

​        b = father[b];

​        father[c] = a;

​    }

​    return a;

}

//合并

void Union(int a, int b) {

​    int fa = findRoot(a);

​    int fb = findRoot(b);

​    if(fa != fb)

​        father[fa] = fb;

}

（4）实际操作时，时常用一个isRoot[n]数组记录每个结点是否作为某个集合的根结点，可以统计最后的集合个数（即根结点的个数，根结点和集合是一一对应的），若数组为int型则可同时记录集合中结点的个数，用isRoot[findRoot[i]]++。这种题要有抽象能力，把有关系的数据抽象为一个集合，作为一个集合去操作，内部实现细节不要想太多，比如结点间的关系相当于集合中的边，不要想得太复杂，然后就是不要把父亲结点和根结点搞混，这种题根本不会考你某个结点的父亲节点是哪个，所以大可放心操作，该用根结点处理就用根结点处理，该路径压缩就路径压缩，当成平时常见的普通的不相交集合就好了，实在不行就画画图，总之，这就是一个**集合**而已，只是有简单地**查找**和**添加**