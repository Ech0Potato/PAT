# 哈希映射Hash

（1）定义：将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素

（2）整数散列

① 最常见的考法是直接把输入的数作为数组的下标来对这个数的性质进行统计， 一般比对两个数列（字符串）重复出现的数字（字符）时使用，基本思路是输入两个数列，然后分别循环遍历两个数列，一次标记，一次输出即可；或者统计一个数列中的数字出现次数

② 其他常用散列函数

直接定址法：H(key) = key（直接变换，即①）

​    H(key) = a * key + b（线性变换）

平方取中法：取key的平方的中间若干位作为hash值（基本不用）

除留取余法：H(key) = key % mod

（表长Tsize不小于mod，一般mod直接取成与Tsize相等）

③ 解决冲突的方法

线性探查法（Linear probing）：检查H(key)+1

平方探查法（Quadratic probing）：

1> 检查H(key)±k²

2> 超过表长则H(key)+k² % Tsize

3> 出现H(key)-k²<0则将((H(key)-k²) % Tsize + Tsize) % Tsize作为结果

链地址法（拉链法）：设定一个数组Link，将H(key)相同的key连接成单链表

如果不是直接考解决冲突的方法，一般直接使用hash（见①）或用STL map即可解决

 

 

（3）字符串hash

① 用整数表示二维整点P：若P(x,y)，0≤x,y≤range，则H(P)=x * range + y

②	将字符串S映射为一个整数，使得该整数可以尽可能唯一地代表字符串S

1> 假设字符串均由大写字母A - Z组成，把A - Z视为0 - 25，进行二十六进制	转换为十进制，代码如下：

const int M = 26 * 26 * 26 （len个26）+ 10; //字符串散列成的数字上界

int hashFunc (char S[], int len) {

int id = 0;

for (int i = 0; i < len; i++){

id = id * 26 + (S[i] - ‘A’); //将二十六进制转换为十进制

}

return id;

}

2> 若出现小写字母，则A - Z为0 - 25，a - z为26 - 51，进行五十二进制转十	进制，见晴神P109

3> 若出现数字，增大进制数至62，见晴神P110

 

注：Hash表的平均查找时间即查找次数除以元素个数，可能会考到