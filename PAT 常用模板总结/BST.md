# 二叉查找树BST

（1）首先明确BST的定义：数据域顺序总是左子树<根结点<右子树，二叉搜索树是二叉树，因此基本操作和二叉树相同，重要模板见前面

（2）几个重要性质：

① 对二叉查找树进行中序遍历，遍历的结果是有序的，即BST的中	序遍历序列是递增的（若题目给出一组权值，那么从小到大排序，中序遍历的同时赋值，便可以形成一棵BST）

② BST的镜像树是指交换二叉树的所有结点的左右子树而形成的树（即数据域左子树>根结点>右子树），对镜像树的遍历只需要在原树的遍历时交换左右子树的访问顺序

③ **完全二叉查找树**具有**完全二叉树的**所有**性质**：完全二叉树**根结点编号为1**，设任一结点编号为n，则其**左孩子编号为2n**，**右孩子编号为2n+1**；可以通过一个大小为2^k的数组来存放所有结点的信息，k为最大高度（实际解题时数组大小只需设为结点个数上限+1）；该数组中元素**存放**的**顺序**即**为**完全二叉树的**层序遍历序列**；判断是否为**叶结点的标志**为该结点（记为root）的**左子结点的编号2\*root大于结点总个数n**；判断是否为**空结点的标志**为该结点**下标root是否大于结点总个数n**（做题可能需要将BST和完全二叉树的性质结合起来使用）

<br />

（3）没有遇到但可能考到的删除操作的步骤：

设当前结点为root

① root为空直接返回

② root权值恰为给定权值，进入删除处理

a>若不存在左右孩子，则为叶子结点，直接删除

b>若存在左孩子，则在左子树中寻找前驱pre，用pre的数据覆盖root，删除pre

c>若存在右孩子，在右子树中寻找后继next，用next的数据覆盖root，删除next

③ root权值大于给定权值，在左子树中递归

④ root权值小于给定权值，在右子树中递归